# Code Review 规范

## Code Review 流程

`开发` 前：

- reviewer 和 author 一起参加需求评审
- reviewer 可以在对应的需求上建 review 任务

`review` 前：

- author 得保证代码质量：代码满足团队规范且基本测试通过，
- author 提 `MR` 时机：
   - 大需求：5天以上，任务关闭时。
   - 小需求：5天以内，直接提 `MR` ，提测时。
- author 在  `MR`  内提供改动点描述，小改动提供原因（在 `MR` 描述多行文本框内）
- reviewer 熟悉需求、设计、代码实现（一起参加需求评审）

提 `MR` 方式：组员提 `MR` 给 owner ， owner 提给其他 owner 或者组长或者其他熟悉业务或相关技术的人。


`review` 中：

- 大需求：
   - review 方式： `MR` + 会议
   - author 大致讲解需求和整体设计，然后讲解核心代码实现
   - reviewer 提出问题，author确认是否是问题
   - 对发现的问题进行记录，分类处理，给出会议结论
- 小需求：
   - review 方式： `MR` 
   - reviewer 直接在 `MR` 填写评论


Code Review 本身是个高强度的活动，我们根据定义 `Review List` 去考察代码。`Review List` 保证了Code Review的质量下限，且不影响与会者发挥主观能动性，发现其他问题。

此外，也需要避免在没有明确规范的问题下过多争执。达到同样的效果，A方法可以，B方法也可以，如果团队没有约束用哪种方法，那么就不要在 Code Review 的时候过多讨论，可以在review 后再对 `Review List` 进行补充。


`review` 后：

review 会议结束并不意味这个 review 这个活动结束，因为还有待解决的问题，CR 需要修改的点太多时，根据分类进行处理：

- bug型：需要在需求上线前修改完
- 优化型：一般情况在需测试阶段修改完，太多无法完成时，reviewer提需求，走正常技术需求排期。


## Merge Requests List（MR关注列表）

1. author 也需要熟悉 CR 关注列表
2. 自测通过后才提测和提 MR
3. MR需要注意地方
   1. 标题行：填写需求名/bug名。
   2. 描述栏：大需求描述主要功能点/小需求描述主要改动点/bugfix描述改动原因或bug背景；最后添加需求或者bug的链接。

## Code Review List (CR关注列表)

公共 `Review List` ，也就是几乎所有代码cr都需要按照此规范：

1. git commit提交规范
   1. 前缀说明
      - feat: 新特性
      - fix: 修改问题
      - refactor: 代码重构
      - docs: 文档修改
      - chore: 其他修改
      - test: 测试用例修改
      - style: 代码格式修改等等
   2. 每次commit尽量要描述清除改动点/改动内容/改动原因

2. 代码规范（JS/CSS）
   1. 可读性：注释、文件/函数/变量/常量等命名
   2. 函数体长度/类长度 
      1. 函数体太长，不好阅读，一般建议不要超过50行
      2. 类太长，如超过1000行，那可能就要看下是否违反了"单一职责"原则.
   3. 参数个数：不要太多，一般不要超过3个，超过3个，建议使用对象
   4. 避免行内样式写法：尽量使用className来使用样式
   5. TS代码需要满足TS规范
   6. CSS代码需要满足CSS规范
   7. 非必要的代码注释/无用代码需要清理

3. 代码质量
   1. 注释：恰到好处的注释，能够帮助我们理解函数/类的作用。注：方法函数、组件、枚举项、常量前都要加注释.（待补充注释规范-胡涛）
   2. 单一职责原则：这是经常被违背的原则，也是最难运用好的原则. 
      1. 一个类只做一类相关的事情
      2. 一个函数/方法，最好只做一件事情
   3. 行为是否统一：错误处理、错误提示、弹出框等等是否统一 ，比如：埋点时机（无事件触发时也报）
   4. 代码污染：代码有没有对其他模块强耦合，改动是否印象其他模块。(改动公共部分的代码需要注意)
   5. 重复代码：
      1. 有没有把公用组件，可复用的代码、函数抽取出来
      2. 接口有没有抽离、字典表数据提取
      3. 需使用常量表示一些状态值等（代码里面不能出现无解释意义的数字、字符）
   6. 开放-封闭原则：简单理解是，看代码好不好扩展。`（扩展的定义待补充）`
   7. 健壮性：
      1. 核心数据有没有强制校验？
      2. 对业务有没有考虑完整，逻辑是否健壮，比如接口挂掉或者返回数据错误时容错处理。
      3. 有没有其他潜在的bug？
      4. 有没有内存泄露？有没有循环依赖？是否存在死循环？
      5. 代码是否足够简单，没有很深的if判断或者循环
      6. 是否有冗余代码
         1. 当某个属性用到的次数少的时候，减少不必要的解构
      7. 定义ts类型时，需要定义清晰的类型边界，避免依赖不必要的类型声明
      8. 安全取值规范: 统一使用 `lodash` 中的 `get` 函数
   8. 错误处理：有没有很好的Error Handling? 如网络出错， IO出错等。try catch 一定要有逻辑处理或者错误上报。
   9. 性能：
      1. 接口调用时机是否合适？（高频接口可能影响后端性能）
      2. 接口是否需要在服务端进行请求？
      3. 图片是否经过适当的裁剪或压缩，cdn图片使用Webp格式图片
      4. 静态图片是否经过压缩
      5. 图片懒加载（长页面，图片较多时使用）
      6. 能用css完成的动画就用css，尽量避免使用js来制作动画。
      7. 关注会引起回流的操作，比如 css 属性改变，内容的改变等
      8. 高频次、异步操作，使用防抖、节流。
      9. 制作JS动画时，使用requestAnimationFrame取代setTimeout和setInterva；使用定时器时，用setTimeout取代setInterval，setInterval会一直占用内存。
      10. 页面布局设计是否合理，有没有优化空间(通过工具可以查看布局)
      11. 进入退出页面的生命周期、点击操作是否同步存在耗时较长的操作
      12. 页面缓存的必要性（针对首屏或复杂页面）
      13. 列表性能（滑动过程是否存在卡顿）
      14. 动画性能（内存及流畅度）
      15. 注意render次数，尽量减少重复渲染，一些类似虚线的效果可以考虑用画布来绘制或者css来实现，而不是重复视图的堆砌
      16. 非必要接口不要阻塞主要流程（多个接口相互关联时存在阻塞是正常的，没关联的不需要进行阻塞）
      17. 类似flatlist这种可复用item的组件，注意设置好key，确保唯一。另外把高度提前算好，也可以提升性能
      18. 代码中使用遍历操作，关注遍历的数据量是否过大，单次循环执行时间是否存在耗时情况
      19. 涉及到复杂页面或长列表生成，关注DOM节点数量，是否对渲染造成影响
      20. 图片（尤其首屏）等容器是否使用占位高度，以避免渲染结果抖动（CLS：Cumulative Layout Shift）
      21. 组件循环遍历使用的key 是否合理，避免使用 index作为下标
      22. 减少不必要的dom层级，控制dom节点数
      23. 组件注意区分有无状态，能不使用状态组件就不使用，无状态组件 进来使用函数组件管理 (RN)
      24. 动画尽量使用useNative (RN)
      25. 所有页面级监听在页面销毁后要清理监听
      26. React 中组件参数如果是函数，函数组件需要使用 `useCallback` 缓存，类组件需要把函数定义成类的属性，避免组件重复render

4. 用户体验
   1. 关键操作按钮、操作接口的按钮的防重复点击处理
   2. 是否可以使用预请求
   3. 图片加载是否会导致页面抖动
   4. 体验方面，某些页面合理使用Viewport 等meta头部，禁用手机号识别等功能；
   5. 复杂页面，有分页加载的，可考虑提前渲染屏幕外的组件，但要注意不要占用过多内存，避免崩掉
   6. Loading组件的时候 注意关闭安卓用户的返回按钮（产品要求情况除外）

5. 是否满足功能需求
   1. 有没有多做
   2. 有没有少做
   3. 需求有没有潜在的bug


其他可能存在的 `Review List`：

- 有无引入共用模块（外部npm），是否经过评估（重点关注）
- 是否通过域名做为条件判断，域名后期是否有改动的可能
- 版本判断是否问题
- 前端里面是否有过于复杂的业务逻辑


## 待补充事项

- 代码规范（注释规范/JS规范/CSS规范）